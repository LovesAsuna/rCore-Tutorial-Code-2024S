# 问答作业 4

1. SV39 页表页表项的组成

![../_images/sv39-pte.png](https://learningos.cn/rCore-Tutorial-Guide-2024S/_images/sv39-pte.png)

上图为 SV39 分页模式下的页表项，其中 [53:10] 这 44 位是物理页号，最低的 8 位 [7:0] 则是标志位，它们的含义如下：

- 仅当 V(Valid) 位为 1 时，页表项才是合法的；
- R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；
- U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；
- G 我们不理会；
- A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；
- D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。

2. 缺页

   1. 哪些异常可能是缺页导致的

      1. ```rust
         Trap::Exception(Exception::StoreFault)
         | Trap::Exception(Exception::StorePageFault)
         | Trap::Exception(Exception::LoadFault)
         | Trap::Exception(Exception::LoadPageFault)
         ```

   2. Lazy 策略的好处
      1. 更加节省内存。根据局部性原理，大部分代码段可能不会被使用，只有频繁使用的代码才最有必要加载进内存中。

   3. 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存

      1. 页数量：(10 * 1024 * 1024 * 1024) / (4 * 1024) = 2621440 页

      2. 考虑三级页表，每级页表包含 512 个页表项

         1. 三级页表项数目 = 页数量 = 2621440个
         2. 二级页表项数目 = 2621440 / 512 = 5120 个
         3. 一级页表项数目 = 5120 / 512 = 10 个

         但一级页表项本身是作为根页的一部分，只是有了有效和无效的区分，因此总占用为

         (2621440 + 5120) * 8 + 4096 = 21016576 B，约为20.02 MB

   4. 如何才能实现 Lazy 策略，缺页时又如何处理？
      1. 维护地址到是否有效的映射，申请内存时先写入映射，而不实际修改页表，到使用时(缺页)，判断该地址是否在映射内，如果在就进行页表写入，实际申请内存

   5. 页面失效如何表现在页表项(PTE)上
      1. V 变为 0

3. 单页表

   1. 如何更换页表

      **保存当前页表**：在上下文切换时，操作系统会保存当前进程的页表指针到陷入上下文中。

      **加载新页表**：操作系统会将新的进程的页表指针加载到页表寄存器中。

      **刷新TLB（Translation Lookaside Buffer）**：为了确保没有旧的虚拟地址映射残留，操作系统会刷新TLB，这是一种硬件缓存，用于快速查找最近使用的地址转换。

   2. 如何控制用户态无法访问内核页面

      1. 创建出内核页面的时候就需要确保其不包含 U 标志位，这样用户态就无法访问该页面

   3. 单页表有何优势

      **内存使用效率**：由于用户态和内核态共享同一张页表，不需要为每个进程维护两张页表，减少了内存开销。

      **切换开销低**：在进行用户态与内核态切换时，不需要更换页表，只需切换权限级别即可，提高了性能。

      **设计简洁**：单页表结构相对简单，易于实现和管理。

   4. 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表

      **从用户态切换到内核态**：当用户态进程需要执行内核代码时（例如系统调用或中断处理），操作系统会切换到内核页表，这样内核地址空间完全隔离。

      **从内核态返回到用户态**：当内核态操作完成后，操作系统会切换回用户态页表，以保护内核地址空间不被用户态访问。
      
      如果我写一个单页表操作系统，页表更换会在以下情况发生：
      
      1. **上下文切换时**：在不同进程间切换时，需要更换页表来映射当前进程的虚拟地址空间到物理内存。
      2. **进程创建时**：当一个新进程被创建时，操作系统需要为其分配新的页表，并进行初始化。
      3. **进程终止时**：当一个进程终止时，操作系统需要回收其页表并释放相应的内存资源。
      
      这些策略确保了操作系统能够高效、安全地管理虚拟内存，并防止不同进程间的不正当访问。