# 问答作业 5

## 实现的功能

核心通过 `TaskControlBlock::new` 实现的 `spawn 系统调用`。并简单的实现了 `stride` 调度策略。

## stride 算法深入

* 实际情况是轮到 p1 执行吗？为什么？

实际情况是不会轮到 p1 执行。因为 `stride` 值是无符号 8 位整数，所以 `stride` 值在 0 到 255 之间循环。当 p2 的 `stride` 值增加到一定值时，再进行 `pass` 的累加，会发生溢出。这种情况下，如果直接比较`stride` 值，会导致错误的结果。

* **不考虑溢出的情况下** *, 在进程优先级全部 >= 2 的情况下，如果严格按照算法执行，那么 STRIDE_MAX – STRIDE_MIN <= BigStride / 2。*为什么？

在进程优先级全部 >= 2 的情况下，由 `pass = BigStride / priority` 可得 `pass > BigStride / 2`。

- 实现如下：

```rust
use core::cmp::Ordering;

struct Stride(u64);

impl PartialOrd for Stride {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if other.0 > BIG_STRIDE / 2 {
            return Some(Ordering::Less);
        } 
        if self.0 > BIG_STRIDE / 2 {
            return Some(Ordering::Greater);
        }
        self.0.partial_cmp(&other.0)
    }
}

impl PartialEq for Stride {
    fn eq(&self, other: &Self) -> bool {
        self.partial_cmp(other).is_some_and(|it| it == Ordering::Equal)
    }
}
```

